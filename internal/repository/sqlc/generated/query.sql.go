// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package sqlc

import (
	"context"
	"time"

	"github.com/shopspring/decimal"
)

const getAggregates = `-- name: GetAggregates :many
SELECT time_bucket($1, c.timestamp)::timestamptz AS bucket,
    asset_id,
    first(open, c.timestamp)::numeric                   AS open,
    max(high)::numeric                                  AS high,
    min(low)::numeric                                   AS low,
    last(close, c.timestamp)::numeric                   AS close,
    sum(volume)::numeric                                AS volume
FROM candles c
where c.asset_id = $2
  and c.timestamp:: date BETWEEN $3
  AND $4
GROUP BY bucket, asset_id
ORDER BY bucket ASC
`

type GetAggregatesParams struct {
	TimeBucket interface{}
	AssetID    int32
	Starttime  *time.Time
	Endtime    *time.Time
}

type GetAggregatesRow struct {
	Bucket  *time.Time
	AssetID int32
	Open    decimal.Decimal
	High    decimal.Decimal
	Low     decimal.Decimal
	Close   decimal.Decimal
	Volume  decimal.Decimal
}

// ------------------ AGGREGATES ---------------------
// Get aggregate
func (q *Queries) GetAggregates(ctx context.Context, arg GetAggregatesParams) ([]GetAggregatesRow, error) {
	rows, err := q.db.Query(ctx, getAggregates,
		arg.TimeBucket,
		arg.AssetID,
		arg.Starttime,
		arg.Endtime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAggregatesRow
	for rows.Next() {
		var i GetAggregatesRow
		if err := rows.Scan(
			&i.Bucket,
			&i.AssetID,
			&i.Open,
			&i.High,
			&i.Low,
			&i.Close,
			&i.Volume,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetById = `-- name: GetAssetById :one
SELECT id, ticker, name, type, created_at, modified_at
FROM assets
WHERE id = $1
`

// Get asset by id
func (q *Queries) GetAssetById(ctx context.Context, id int64) (Asset, error) {
	row := q.db.QueryRow(ctx, getAssetById, id)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.Ticker,
		&i.Name,
		&i.Type,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const getAssetByTicker = `-- name: GetAssetByTicker :one
SELECT id, ticker, name, type, created_at, modified_at
FROM assets
WHERE ticker = $1
`

// Get asset by ticker
func (q *Queries) GetAssetByTicker(ctx context.Context, ticker string) (Asset, error) {
	row := q.db.QueryRow(ctx, getAssetByTicker, ticker)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.Ticker,
		&i.Name,
		&i.Type,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const getAssets = `-- name: GetAssets :many
SELECT id, ticker, name, type, created_at, modified_at
FROM assets
`

// ------------------ ASSETS ---------------------
// Get assets
func (q *Queries) GetAssets(ctx context.Context) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.Ticker,
			&i.Name,
			&i.Type,
			&i.CreatedAt,
			&i.ModifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetsByType = `-- name: GetAssetsByType :many
SELECT id, ticker, name, type, created_at, modified_at
FROM assets
WHERE type = $1
`

// Get assets by type
func (q *Queries) GetAssetsByType(ctx context.Context, type_ Assettype) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.Ticker,
			&i.Name,
			&i.Type,
			&i.CreatedAt,
			&i.ModifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCandleRangeByTicker = `-- name: GetCandleRangeByTicker :one
SELECT id, ticker, name, type, created_at, start_time, end_time
FROM asset_candle_range
WHERE ticker = $1
`

// ------------------ CANDLES ---------------------
// Get min/max candle by assetId
func (q *Queries) GetCandleRangeByTicker(ctx context.Context, ticker string) (AssetCandleRange, error) {
	row := q.db.QueryRow(ctx, getCandleRangeByTicker, ticker)
	var i AssetCandleRange
	err := row.Scan(
		&i.ID,
		&i.Ticker,
		&i.Name,
		&i.Type,
		&i.CreatedAt,
		&i.StartTime,
		&i.EndTime,
	)
	return i, err
}
